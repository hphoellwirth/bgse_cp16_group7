rss_ridge <- cross.validation(y, X, 50, ridge.reg)
rss_lasso <- cross.validation(y, X, 50, lasso.reg)
rss_ridge <- cross.validation(y, X, 0.1, ridge.reg)
rss_lasso <- cross.validation(y, X, 0.1, lasso.reg)
rm(list = ls())
# BEGIN CODE
# (1)
# ordinary least squares estimator
lin.reg <- function(y, X) {
beta <- solve( t(X)%*%X, t(X)%*%y )
return (beta)
}
# (2)
# ridge estimator
ridge.reg <- function(y, X, lambda) {
M <- ncol(X)
beta <- solve( t(X)%*%X + lambda * diag(M), t(X)%*%y )
return (beta)
}
# (3)
# LASSO estimator (using shooting algorithm)
lasso.reg <- function(y, X, lambda) {
# initialize with least squares estimator
beta <- lin.reg(y, X)
M <- ncol(X)
# iteratively converge to optimal beta
for (i in 1:10) {
beta.prev <- beta
# minimize objective function one coordinate at a time
for (k in 1:M) {
x.aux <- X[,k]
y.aux <- y - X[,setdiff(1:M,k)] %*% beta[setdiff(1:M,k)]
# compute LS estimate of k-th coefficient
cov <- sum(y.aux * x.aux)
var <- sum(x.aux * x.aux)
#beta.ls <- cov/var
# update lasso estimate of k-th coefficient
beta[k] <- sign(cov/var) *
max(c(0, abs(cov/var - lambda/(2*var))))
}
# stop if converged
if (sum(abs(beta - beta.prev)) < 1e-6)
return(beta)
}
return (beta)
}
# (4)
# 5-fold cross validation
cross.validation <- function(y, X, lambda, pen.reg) {
K <- 5
N <- length(y)
rss <- rep(0,K)
for (i in 1:K) {
# compute range of validation set
f <- (i-1) * ceiling(N/K) + 1
t <- min(c(i * ceiling(N/K), N))
# train beta on training set and compute RSS for validation set
beta <- pen.reg(y[setdiff(1:N,f:t)], X[setdiff(1:N,f:t),,drop=FALSE], lambda)
rss[i] <- sum((y[f:t] - X[f:t,,drop=FALSE] %*% beta)**2)
}
return(mean(rss))
}
# END CODE
problemset.function.list <- c('lin.reg','ridge.reg','lasso.reg','cross.validation')
problemset.test <- function(){
time <- system.time({
set.seed(12345)
P <- 10
T <- 1000
X    <- matrix(rnorm(T*P),T,P)
eps  <- matrix(0.1*rnorm(T),T,1)
beta <- rnorm(P)
y <- X %*% beta + eps
beta.ls    <- lin.reg(y,X)
beta.ridge <- ridge.reg(y,X,0.1)
beta.lasso <- lasso.reg(y,X,0.1)
cv <- cross.validation(y, X, 0.1, ridge.reg)
})[3]
return( list(ls=beta.ls,ridge=beta.ridge,lasso=beta.lasso,cv=cv,time=time) )
}
problemset.check <- function(test,solutions){
check    <- rep(0,3)
check[1]    <- max( abs(test$ls - solutions$ls) ) < 1e-6
check[2]    <- max( abs(test$ridge - solutions$ridge) ) < 1e-6
check[3]    <- max( abs(test$lasso - solutions$lasso) ) < 1e-3
check[4]    <- max( abs(test$cv - solutions$cv) ) < 1e-3
check[ !is.finite(check) ] <- 0
return( mean(check) )
}
test <- problemset.test()
#
# utility functions for problemset 5
#
rm(list = ls())
# simulate linear regression data
sim.lin.data <- function(N, M) {
y    <- matrix(0,N,1)
X    <- matrix(0,N,M)
beta <- matrix(0,M,1)
# draw N error terms from t-distribution centered around 0
# and with 10 degrees of freedom
eps <- rt(N,10)
X[] <- rnorm(N*M,0,1)
beta[] <- 0.5
# compute target values
for (i in 1:N) {
y[i] <- X[i,] %*% beta + eps[i]
}
return (list(y=y,X=X))
}
# simulate data
data <- sim.lin.data(500,30)
y <- data$y
X <- data$X
# plot data
plot(X[,1],y)
abline(0,0.5,col="black")
# run OLS regression
beta.ls <- lin.reg(y,X)
abline(abline(0, beta.ls, col="red"))
# run ridge regression
beta.ridge <- ridge.reg(y,X,50)
abline(abline(0, beta.ridge, col="blue"))
# run lasso regression
beta.lasso <- lasso.reg(y,X,50)
abline(abline(0, beta.lasso, col="green"))
# test cross-validation
rss_ridge <- cross.validation(y, X, 0.1, ridge.reg)
rss_lasso <- cross.validation(y, X, 0.1, lasso.reg)
rm(list = ls())
# BEGIN CODE
# (1)
# ordinary least squares estimator
lin.reg <- function(y, X) {
beta <- solve( t(X)%*%X, t(X)%*%y )
return (beta)
}
# (2)
# ridge estimator
ridge.reg <- function(y, X, lambda) {
M <- ncol(X)
beta <- solve( t(X)%*%X + lambda * diag(M), t(X)%*%y )
return (beta)
}
# (3)
# LASSO estimator (using shooting algorithm)
lasso.reg <- function(y, X, lambda) {
# initialize with least squares estimator
beta <- lin.reg(y, X)
M <- ncol(X)
# iteratively converge to optimal beta
for (i in 1:10) {
beta.prev <- beta
# minimize objective function one coordinate at a time
for (k in 1:M) {
x.aux <- X[,k]
y.aux <- y - X[,setdiff(1:M,k)] %*% beta[setdiff(1:M,k)]
# compute LS estimate of k-th coefficient
cov <- sum(y.aux * x.aux)
var <- sum(x.aux * x.aux)
#beta.ls <- cov/var
# update lasso estimate of k-th coefficient
beta[k] <- sign(cov/var) *
max(c(0, abs(cov/var - lambda/(2*var))))
}
# stop if converged
if (sum(abs(beta - beta.prev)) < 1e-6)
return(beta)
}
return (beta)
}
# (4)
# 5-fold cross validation
cross.validation <- function(y, X, lambda, pen.reg) {
K <- 5
N <- length(y)
rss <- rep(0,K)
for (i in 1:K) {
# compute range of validation set
f <- (i-1) * ceiling(N/K) + 1
t <- min(c(i * ceiling(N/K), N))
# train beta on training set and compute RSS for validation set
beta <- pen.reg(y[setdiff(1:N,f:t)], X[setdiff(1:N,f:t),,drop=FALSE], lambda)
rss[i] <- sum((y[f:t] - X[f:t,,drop=FALSE] %*% beta)**2)
}
return(mean(rss))
}
# END CODE
problemset.function.list <- c('lin.reg','ridge.reg','lasso.reg','cross.validation')
problemset.test <- function(){
time <- system.time({
set.seed(12345)
P <- 10
T <- 1000
X    <- matrix(rnorm(T*P),T,P)
eps  <- matrix(0.1*rnorm(T),T,1)
beta <- rnorm(P)
y <- X %*% beta + eps
beta.ls    <- lin.reg(y,X)
beta.ridge <- ridge.reg(y,X,0.1)
beta.lasso <- lasso.reg(y,X,0.1)
cv <- cross.validation(y, X, 0.1, ridge.reg)
})[3]
return( list(ls=beta.ls,ridge=beta.ridge,lasso=beta.lasso,cv=cv,time=time) )
}
problemset.check <- function(test,solutions){
check    <- rep(0,3)
check[1]    <- max( abs(test$ls - solutions$ls) ) < 1e-6
check[2]    <- max( abs(test$ridge - solutions$ridge) ) < 1e-6
check[3]    <- max( abs(test$lasso - solutions$lasso) ) < 1e-3
check[4]    <- max( abs(test$cv - solutions$cv) ) < 1e-3
check[ !is.finite(check) ] <- 0
return( mean(check) )
}
#
# utility functions for problemset 5
#
#rm(list = ls())
# simulate linear regression data
sim.lin.data <- function(N, M) {
y    <- matrix(0,N,1)
X    <- matrix(0,N,M)
beta <- matrix(0,M,1)
# draw N error terms from t-distribution centered around 0
# and with 10 degrees of freedom
eps <- rt(N,10)
X[] <- rnorm(N*M,0,1)
beta[] <- 0.5
# compute target values
for (i in 1:N) {
y[i] <- X[i,] %*% beta + eps[i]
}
return (list(y=y,X=X))
}
# simulate data
data <- sim.lin.data(500,30)
y <- data$y
X <- data$X
# plot data
plot(X[,1],y)
abline(0,0.5,col="black")
# run OLS regression
beta.ls <- lin.reg(y,X)
abline(abline(0, beta.ls, col="red"))
# run ridge regression
beta.ridge <- ridge.reg(y,X,50)
abline(abline(0, beta.ridge, col="blue"))
# run lasso regression
beta.lasso <- lasso.reg(y,X,50)
abline(abline(0, beta.lasso, col="green"))
# test cross-validation
rss_ridge <- cross.validation(y, X, 0.1, ridge.reg)
rss_lasso <- cross.validation(y, X, 0.1, lasso.reg)
lin.reg <- function(y, X) {
beta <- solve( t(X)%*%X, t(X)%*%y )
return (beta)
}
ridge.reg <- function(y, X, lambda) {
M <- ncol(X)
beta <- solve( t(X)%*%X + lambda * diag(M), t(X)%*%y )
return (beta)
}
lasso.reg <- function(y, X, lambda) {
# initialize with least squares estimator
beta <- lin.reg(y, X)
M <- ncol(X)
# iteratively converge to optimal beta
for (i in 1:10) {
beta.prev <- beta
# minimize objective function one coordinate at a time
for (k in 1:M) {
x.aux <- X[,k]
y.aux <- y - X[,setdiff(1:M,k)] %*% beta[setdiff(1:M,k)]
# compute LS estimate of k-th coefficient
cov <- sum(y.aux * x.aux)
var <- sum(x.aux * x.aux)
# update lasso estimate of k-th coefficient
beta[k] <- sign(cov/var) *
max(c(0, abs(cov/var - lambda/(2*var))))
}
# stop if converged
if (sum(abs(beta - beta.prev)) < 1e-6)
return(beta)
}
return (beta)
}
cross.validation <- function(y, X, lambda, pen.reg) {
K <- 5
N <- length(y)
rss <- rep(0,K)
for (i in 1:K) {
# compute range of validation set
f <- (i-1) * ceiling(N/K) + 1
t <- min(c(i * ceiling(N/K), N))
# train beta on training set and compute RSS for validation set
beta <- pen.reg(y[setdiff(1:N,f:t)], X[setdiff(1:N,f:t),,drop=FALSE], lambda)
rss[i] <- sum((y[f:t] - X[f:t,,drop=FALSE] %*% beta)**2)
}
return(mean(rss))
}
lasso.reg <- function(y, X, lambda) {
# initialize with least squares estimator
beta <- lin.reg(y, X)
M <- ncol(X)
# iteratively converge to optimal beta
for (i in 1:50) {
beta.prev <- beta
# minimize objective function one coordinate at a time
for (k in 1:M) {
x.aux <- X[,k]
y.aux <- y - X[,setdiff(1:M,k)] %*% beta[setdiff(1:M,k)]
# compute LS estimate of k-th coefficient
cov <- sum(y.aux * x.aux)
var <- sum(x.aux * x.aux)
# update lasso estimate of k-th coefficient
beta[k] <- sign(cov/var) *
max(c(0, abs(cov/var - lambda/(2*var))))
}
# stop if converged
if (sum(abs(beta - beta.prev)) < 1e-6)
return(beta)
}
return (beta)
}
rss_lasso <- cross.validation(y, X, 0.1, lasso.reg)
beta.lasso <- lasso.reg(y,X,50)
abline(abline(0, beta.lasso, col="green"))
lasso.reg <- function(y, X, lambda) {
# initialize with least squares estimator
beta <- lin.reg(y, X)
M <- ncol(X)
# iteratively converge to optimal beta
for (i in 1:50) {
beta.prev <- beta
# minimize objective function one coordinate at a time
for (k in 1:M) {
x.aux <- X[,k]
y.aux <- y - X[,setdiff(1:M,k)] %*% beta[setdiff(1:M,k)]
# compute LS estimate of k-th coefficient
cov <- sum(y.aux * x.aux)
var <- sum(x.aux * x.aux)
# update lasso estimate of k-th coefficient
beta[k] <- sign(cov/var) *
max(c(0, abs(cov/var - lambda/(2*var))))
}
# stop if converged
if (sum(abs(beta - beta.prev)) < 1e-6)
return(beta)
}
return (beta)
}
lasso.reg <- function(y, X, lambda) {
# initialize with least squares estimator
beta <- lin.reg(y, X)
M <- ncol(X)
# iteratively converge to optimal beta
for (i in 1:50) {
beta.prev <- beta
# minimize objective function one coordinate at a time
for (k in 1:M) {
x.aux <- X[,k]
y.aux <- y - X[,setdiff(1:M,k)] %*% beta[setdiff(1:M,k)]
# compute LS estimate of k-th coefficient
cov <- sum(y.aux * x.aux)
var <- sum(x.aux * x.aux)
# update lasso estimate of k-th coefficient
beta[k] <- sign(cov/var) *
max(c(0, abs(cov/var - lambda/(2*var))))
}
# stop if converged
if (sum(abs(beta - beta.prev)) < 1e-6)
return(beta)
}
return (beta)
}
problemset.function.list <- c('lin.reg','ridge.reg','lasso.reg','cross.validation')
problemset.test <- function(){
time <- system.time({
set.seed(12345)
P <- 10
T <- 1000
X    <- matrix(rnorm(T*P),T,P)
eps  <- matrix(0.1*rnorm(T),T,1)
beta <- rnorm(P)
y <- X %*% beta + eps
beta.ls    <- lin.reg(y,X)
beta.ridge <- ridge.reg(y,X,0.1)
beta.lasso <- lasso.reg(y,X,0.1)
cv <- cross.validation(y, X, 0.1, ridge.reg)
})[3]
return( list(ls=beta.ls,ridge=beta.ridge,lasso=beta.lasso,cv=cv,time=time) )
}
problemset.check <- function(test,solutions){
check    <- rep(0,3)
check[1]    <- max( abs(test$ls - solutions$ls) ) < 1e-6
check[2]    <- max( abs(test$ridge - solutions$ridge) ) < 1e-6
check[3]    <- max( abs(test$lasso - solutions$lasso) ) < 1e-3
check[4]    <- max( abs(test$cv - solutions$cv) ) < 1e-3
check[ !is.finite(check) ] <- 0
return( mean(check) )
}
test <- problemset.test()
install.packages("xlsx")}
install.packages("xlsx")
rm(list = ls())
# install/load libraries
suppressMessages(if(!require(openxlsx)){install.packages("openxlsx")})
suppressMessages(if(!require(RMySQL)){install.packages("RMySQL")})
suppressMessages(if(!require(mgcv)){install.packages("mgcv")})
suppressMessages(library("openxlsx"))
suppressMessages(library("RMySQL"))
suppressMessages(library("mgcv"))
setwd("/Users/Hans-Peter/Documents/Masters/14D003/project")
loadFileName <- "data/Air pollutant concentrations 2012 - Dataset complete.xlsx"
dat_PM10  <- read.xlsx(loadFileName, sheet = 2, startRow = 11, colNames = TRUE)
dat_NO2   <- read.xlsx(loadFileName, sheet = 5, startRow = 11, colNames = TRUE)
dat_O3    <- read.xlsx(loadFileName, sheet = 8, startRow = 11, colNames = TRUE)
dat_PM2.5 <- read.xlsx(loadFileName, sheet = 11, startRow = 11, colNames = TRUE)
dat_BaP   <- read.xlsx(loadFileName, sheet = 14, startRow = 11, colNames = TRUE)
dat_NO2[dat_NO2$city_code == "NULL",]$city_code <-
paste0(dat_NO2[dat_NO2$city_code == "NULL",]$country_iso_code,
substr(dat_NO2[dat_NO2$city_code == "NULL",]$city_name,1,5))
dat_O3[dat_O3$city_code == "NULL",]$city_code <-
paste0(dat_O3[dat_O3$city_code == "NULL",]$country_iso_code,
substr(dat_O3[dat_O3$city_code == "NULL",]$city_name,1,5))
dat_PM10[dat_PM10$city_code == "NULL",]$city_code <-
paste0(dat_PM10[dat_PM10$city_code == "NULL",]$country_iso_code,
substr(dat_PM10[dat_PM10$city_code == "NULL",]$city_name,1,5))
dat_PM2.5[dat_PM2.5$city_code == "NULL",]$city_code <-
paste0(dat_PM2.5[dat_PM2.5$city_code == "NULL",]$country_iso_code,
substr(dat_PM2.5[dat_PM2.5$city_code == "NULL",]$city_name,1,5))
dat_BaP[dat_BaP$city_code == "NULL",]$city_code <-
paste0(dat_BaP[dat_BaP$city_code == "NULL",]$country_iso_code,
substr(dat_BaP[dat_BaP$city_code == "NULL",]$city_name,1,5))
countries <- uniquecombs(rbind(data.frame(code = paste0("\"",dat_NO2$country_iso_code,"\""),
name = paste0("\"",dat_NO2$country_name,"\""),
pctTraffic = dat_NO2$percentage_traffic_population),
data.frame(code = paste0("\"",dat_O3$country_iso_code,"\""),
name = paste0("\"",dat_O3$country_name,"\""),
pctTraffic = dat_O3$percentage_traffic_population),
data.frame(code = paste0("\"",dat_PM10$country_iso_code,"\""),
name = paste0("\"",dat_PM10$country_name,"\""),
pctTraffic = dat_PM10$percentage_traffic_population),
data.frame(code = paste0("\"",dat_PM2.5$country_iso_code,"\""),
name = paste0("\"",dat_PM2.5$country_name,"\""),
pctTraffic = dat_PM2.5$percentage_traffic_population),
data.frame(code = paste0("\"",dat_BaP$country_iso_code,"\""),
name = paste0("\"",dat_BaP$country_name,"\""),
pctTraffic = dat_BaP$percentage_traffic_population)))
version
View(countries)
countries <- uniquecombs(rbind(data.frame(code = paste0("\"",dat_NO2$country_iso_code,"\""),
name = paste0("\"",dat_NO2$country_name,"\"")),
data.frame(code = paste0("\"",dat_O3$country_iso_code,"\""),
name = paste0("\"",dat_O3$country_name,"\"")),
data.frame(code = paste0("\"",dat_PM10$country_iso_code,"\""),
name = paste0("\"",dat_PM10$country_name,"\"")),
data.frame(code = paste0("\"",dat_PM2.5$country_iso_code,"\""),
name = paste0("\"",dat_PM2.5$country_name,"\""),
data.frame(code = paste0("\"",dat_BaP$country_iso_code,"\""),
name = paste0("\"",dat_BaP$country_name,"\"")))
)
)
;
countries <- uniquecombs(rbind(data.frame(code = paste0("\"",dat_NO2$country_iso_code,"\""),
name = paste0("\"",dat_NO2$country_name,"\"")),
data.frame(code = paste0("\"",dat_O3$country_iso_code,"\""),
name = paste0("\"",dat_O3$country_name,"\"")),
data.frame(code = paste0("\"",dat_PM10$country_iso_code,"\""),
name = paste0("\"",dat_PM10$country_name,"\"")),
data.frame(code = paste0("\"",dat_PM2.5$country_iso_code,"\""),
name = paste0("\"",dat_PM2.5$country_name,"\"")),
data.frame(code = paste0("\"",dat_BaP$country_iso_code,"\""),
name = paste0("\"",dat_BaP$country_name,"\""))))
countries <- rbind(data.frame(code = paste0("\"",dat_NO2$country_iso_code,"\""),
name = paste0("\"",dat_NO2$country_name,"\"")),
data.frame(code = paste0("\"",dat_O3$country_iso_code,"\""),
name = paste0("\"",dat_O3$country_name,"\"")),
data.frame(code = paste0("\"",dat_PM10$country_iso_code,"\""),
name = paste0("\"",dat_PM10$country_name,"\"")),
data.frame(code = paste0("\"",dat_PM2.5$country_iso_code,"\""),
name = paste0("\"",dat_PM2.5$country_name,"\"")),
data.frame(code = paste0("\"",dat_BaP$country_iso_code,"\""),
name = paste0("\"",dat_BaP$country_name,"\"")))
installed.packages(mgcv)
installed.packages("mgcv")
version("mgcv")
packageVersion(("mgcv"))
update.packages("mgcv")
packageVersion(("mgcv"))
old.packages
old.packages()
o <- old.packages()
View(o)
o <- old.packages()$Package
o$Package
o["mgcv"]
o=="mgcv"
update.packages()
o
type(0)
type(o)
typeof(o)
require(openxlsx)
r <- require(openxlsx)
packageVersion(("mgcv"))
packageVersion("mgcv")
packageVersion("mgcv") < '1.8.15'
packageVersion("mgcv") < '1.8.16'
suppressMessages(if(!require(openxlsx)){install.packages("openxlsx")})
suppressMessages(if(!require(RMySQL)){install.packages("RMySQL")})
suppressMessages(if(!require(mgcv) | packageVersion("mgcv") < '1.8.15'){install.packages("mgcv")})
